# VM

## Execution model

The VM executes a token stream in reading order. Each token is executed as:

```
Select → Bound → Seal
```

### Registers

Minimum required registers:

- `Ω`: ambient/root handle (always defined).
- `F`: current focus handle.
- `R`: last-residue handle (defaults to `⊥`).
- `K`: handle stack (LIFO).
- `E`: environment stack (scoping frames).
- `W`: watchlist or persistent selectors (optional but recommended).
- `OStack_word`: word-scoped obligation stack (LIFO).
- `A`: phrase accumulator (`WordValue[]`).
- `τ`: step counter.

Initial state (before first token):

```
Ω := root scope handle
F := Ω
R := ⊥
K := [F, R]
W := []
OStack_word := []
A := []
τ := 0
```

## Operand selection policy

Each letter declares:

- `arity_req`, `arity_opt`
- `distinct_required`, `distinct_optional`
- `reflexive_ok`
- input/output handle kinds

Required operands are sourced **in order** from:

1. `K` (stack)
2. `W` (watchlist)
3. `F` (focus)
4. `R` (residue)
5. `Ω` (ambient)

Optional operands are supplied only if available without forcing duplicates.

### Underflow policy

If required operands are missing:

- If `reflexive_ok` is true, duplicate the last selected operand.
- Otherwise, fill with `⊥`.

If any filled operand violates the operator’s type signature, the program is ill-formed (compile error).

## Seal policy

`Seal` MUST:

- push `h_out` onto `K`
- set `F := h_out` in the current frame
- set `R := r_out`

`r_out` is total: every letter yields a residue; if none, use `⊥`.

## Two-level algebra (words, phrases)

A **word** is the ordered composition of its letters:

```
W(word) = ℓ1 ⊗ ℓ2 ⊗ ... ⊗ ℓn
```

Where `⊗` is non-commutative and corresponds to sequential execution in reading order (RTL fold).

A **phrase** is the ordered accumulation of word results:

```
P(phrase) = W1 ⊕ W2 ⊕ ... ⊕ Wk
```

Where `⊕` is ordered add = append to a list/sequence.

The VM maintains `A` as the phrase accumulator (ordered list of sealed word values).

### Word sealing

Define a single export function:

```
seal_word(state) -> WordValue
```

`WordValue` is an opaque, profile-defined value representing the sealed output of a word.

Minimum rule:

- If the current word has an explicit “last sealed artifact handle,” export that.
- Else export the current focus `F`.
- If the word is empty, export `⊥` (or the profile’s canonical empty value).

## Space semantics (`□`)

Whitespace tokens execute the **space operator** and are also injected implicitly at the beginning and end of input.

Space behavior:

1. `τ := τ + 1`
2. Resolve **all** pending `OStack_word` obligations using boundary defaults.
3. Export the word result into the phrase accumulator:
   - `A := A ⊕ [ seal_word(state) ]`
4. Reset word-local execution scope so the next word starts clean:
   - clear word-local stacks/obligations (`OStack_word := []`)
   - reset `F := Ω`
   - reset `R := ⊥`
   - reset `K := [F, R]`
5. Commit any buffered event batch to the event log.
6. Optional GC: delete handles not reachable from roots `{Ω, F} ∪ K ∪ W ∪ {R}`.

End-of-input behaves exactly like `□` (commit the final word into `A`).

Note (future): maqaf (`־`) is the explicit “tied words” separator. When trope handling is introduced, maqaf will prevent the `□`-commit and instead join the two sides into a single compound (treat the boundary as a multiplicative join across words). For now, maqaf is not part of execution semantics.

## Interpreter output contract

The phrase interpreter returns:

- `A` as the phrase value (ordered list of `WordValue`).
- Optional but strongly recommended: `trace[i]`, the per-letter trace that produced `A[i]`.

Any higher-level meaning should start from `A[i]` values. Phrase meaning is composition over the list, not implicit cross-word binding.

## Obligations

Obligations are word-scoped and must be discharged in LIFO order.

```
OKind := { MEM_ZONE, SUPPORT } plus any additional kinds declared in `/registry/letters.yaml`.

Obligation := {
  kind: OKind,
  parent: handle_id,
  child: handle_id,
  payload: map,
  tau_created: int
}
```

Boundary defaults (required):

- `MEM_ZONE` → close silently; no export.
- `SUPPORT` → **fall**: log `fall(child,parent,τ)`, set `R := child`, `F := parent`.

Any additional obligation kinds MUST declare their boundary defaults in `/registry/letters.yaml` and in letter specs.

Non-LIFO discharge is a compile error.

## Deterministic error handling

Invalid inputs MUST fail with typed errors:

- Compile-time errors (tokenization/validation)
- Runtime errors (VM/semantics)

No silent fallback for unknown diacritics or invalid nesting.
